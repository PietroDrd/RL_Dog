####### SEQUENTIAL TRAINING ####### 

    @configclass
    class PolicyCfg(ObsGroup):
        """Observations for policy group."""

        # Command Input (What we requires to do)
        velocity_commands = ObsTerm(func=constant_commands)
        
        # Robot State (What we have)
        base_ang_vel = ObsTerm(func=mdp.base_ang_vel, noise=Unoise(n_min=-0.2, n_max=0.2))
        projected_gravity = ObsTerm(
            func=mdp.projected_gravity,
            noise=Unoise(n_min=-0.05, n_max=0.05),
        )
        accel_base = ObsTerm(
            func=my_body_acc,
            params={"asset_cfg": SceneEntityCfg("robot", body_names=["base"])},
            noise=Unoise(n_min=-0.1, n_max=0.1),
        )
        # base_forces = ObsTerm(            # If accel_base does not work i can give forces 
        #     func=mdp.body_incoming_wrench,
        #     scale=0.1,
        #     params={
        #         "asset_cfg": SceneEntityCfg(
        #             "robot", body_names=["base"]
        #         )
        #     },
        # )
            
        # Joint state 
        joint_pos = ObsTerm(func=mdp.joint_pos_rel, noise=Unoise(n_min=-0.01, n_max=0.01))
        joint_vel = ObsTerm(func=mdp.joint_vel_rel, noise=Unoise(n_min=-1.5, n_max=1.5))

        actions   = ObsTerm(func=mdp.last_action)

        def __post_init__(self):
            self.enable_corruption = True   # IDK
            self.concatenate_terms = True   # IDK
